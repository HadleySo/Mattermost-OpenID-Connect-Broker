from sqlalchemy import update
from itsdangerous import URLSafeTimedSerializer
from . import appConfig
from .. import models

from flaskr import app

DB_SSO_PATH = "flaskr/appData/global_sso_token.db"
DB_USER_PATH = "flaskr/appData/user_idp_data.db"

def new_domain_sso(mattermost_id: str, request_headers: dict) -> str:
    """Creates signed string from `user_id` and UUID to enable remote session revocation.
    Each returned value is unique.

    :param mattermost_id: String that is domain unique for the specific user
    :param request_headers: HTTP request headers
    :return: String for cookie value
    """
    import uuid
    import time

    session_id = str(uuid.uuid4())
    token_cookie = False
    since_epoch = int(time.time())

    try:
        serializer = URLSafeTimedSerializer(appConfig.get_domain_sso_secret_key())
        token_cookie =  serializer.dumps([mattermost_id, session_id], salt="DOMAIN_GLOBAL_SSO")
    except Exception as e:
        app.logger.error("ife_sso_token - new_global_sso - " + str(e))
        return False

    # Create instance of SessionTokens
    session_token = models.SessionTokens(mattermost_id = mattermost_id,
                                    session_id = session_id,
                                    valid = True,
                                    created_timedate = since_epoch,
                                    cf_ray = request_headers.get("CF-RAY", None),
                                    ip_address = request_headers.get("CF-Connecting-IP", None),
                                    cf_country = request_headers.get("CF-IPCountry", None),
                                    user_agent = request_headers.get("User-Agent", None)[:1020],
                                    cf_ipcity = request_headers.get("CF-IPCity", None),
                                    cf_iplongitude = request_headers.get("CF-IPLongitude", None),
                                    cf_iplatitude = request_headers.get("CF-IPLatitude", None),
                                    cf_region = request_headers.get("CF-Region", None),
                                    cf_timezone = request_headers.get("CF-Timezone", None)
                                    )

    models.db.session.add_all([session_token])
    models.db.session.commit()


    return token_cookie

def handle_revoke_current_session(token_cookie: str) -> bool:
    """Revokes a user session given a cookie value. 
    If session is invalid, revokes all sessions for that user, if user is available. 
    If session is valid will only revoke given session.

    :param return: Bool if given session was valid
    """
    result = validate_domain_session(token_cookie)

    if result['result'] != True:
        if result['user_id'] != None:
            revoke_user_all_sessions(result['user_id'])
        return False        
    elif result['result'] == True:
        revoke_user_current_sessions(result['user_id'], result['session_id'])
        return True

def revoke_user_current_sessions(user_id: str, session_id: str) -> bool:
    """Removes session from table of valid tokens. Will always return true, even if `user_id` and `session_id` does not exist.
    
    :param user_id: String that is domain unique for the specific user, as given in `new_domain_sso()`
    :param session_id: ID of signed token value, generated by `new_domain_sso()`
    """

    stmt_01 = (update(models.SessionTokens).where(models.SessionTokens.mattermost_id == user_id).where(models.SessionTokens.session_id == session_id)\
               .values({"valid": False}))
    models.db.session.execute(stmt_01)
    models.db.session.commit()


    return True

def revoke_user_all_sessions(user_id: str) -> bool:
    """Removes all sessions for given user from table of valid tokens. Will always return true.

    :param user_id: String that is domain unique for the specific user, as given in `new_domain_sso()`
    """
    stmt_01 = (update(models.SessionTokens).where(models.SessionTokens.mattermost_id == user_id)\
               .values({"valid": False}))
    models.db.session.execute(stmt_01)
    models.db.session.commit()
    return True

def revoke_domain_session() -> bool:
    """Removes all sessions for all users from table of valid tokens.Will always return true.
    """
    stmt_01 = (update(models.SessionTokens)\
               .values({"valid": False}))
    models.db.session.execute(stmt_01)
    models.db.session.commit()

    return True


def validate_domain_session(token_cookie: str) -> dict:
    """Validate if given `token_cookie` is valid. 
    Checks for valid serialization and that exactly one record exists (has not been revoked).

    :param token_cookie: String of cookie value, signed list of `user_id` and `session_id`
    :param return: Dict of {"result": bool, "user_id": str, "session_id": str, "record_count": int}
    """

    validate_result = {"result": False,
                       "user_id": None,
                       "session_id": None,
                       "record_count": -1}

    serializer = URLSafeTimedSerializer(appConfig.get_domain_sso_secret_key())
    try:
        user_id, session_id = serializer.loads(token_cookie, salt="DOMAIN_GLOBAL_SSO")
    except:
        return validate_result

    orm_result = models.db.session.query(models.SessionTokens)\
        .filter(models.SessionTokens.valid == True)\
        .filter(models.SessionTokens.mattermost_id == user_id)\
        .filter(models.SessionTokens.session_id == session_id)\
            .all()

    if len(orm_result) != 1:
        return validate_result
        
    validate_result['result'] = True
    validate_result['user_id'] = user_id
    validate_result['session_id'] = session_id
    return validate_result

